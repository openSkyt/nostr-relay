<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>chat</title>
    <script src="https://bitcoincore.tech/apps/bitcoinjs-ui/lib/bitcoinjs-lib.js"></script>
    <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f2f2f2;
            margin: 0;
            padding: 0;
        }

        #login {
            padding: 1.25rem;
        }

        h1 {
            color: #333;
        }

        button {
            margin-right: 0.625rem;
            cursor: pointer;
            padding: 0.625rem;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 0.3125rem;
        }

        button:hover {
            background-color: #0056b3;
        }

        label {
            display: block;
            margin: 0.625rem 0;
            color: #555;
        }

        input {
            padding: 0.625rem;
            width: 100%;
            box-sizing: border-box;
            border: 0.0625rem solid #ccc;
            border-radius: 0.3125rem;
        }

        section {
            border-radius: 0.5rem;
            background-color: #f5f5f5;
            border-bottom: 1px solid yellow;
            overflow: hidden;

        }

        section span + span {
            margin-left: 2rem;
        }

        section p {
            padding: 1rem;
        }

        th a {
            color: white;
        }

        section p:nth-child(even) {
            background-color: white;
            overflow: hidden;
            border-radius: 1rem;
        }

        a {
            color: #007bff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }


        #actionBar {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #f5f5f5;
            padding-left: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-top: 1px solid #ccc;
        }

        .actionBarTextField {
            flex-grow: 1;
            margin-right: 1rem;
            display: flex;
            align-items: center;
        }

        .actionBarTextField input {
            flex-grow: 1;
            padding: 0.75rem;
            font-size: 1rem;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 0.5rem;
            outline: none;
        }

        .submitButton {
            margin-right: 2rem;
            width: 32px;
            height: 32px;
            border: none;
            background-color: #007bff;
            color: #fff;
            cursor: pointer;
        }

        #wrapper {
            display: flex;
        }

        #chat {
            flex-grow: 1;
        }

        #log {
            width: 23%;
            flex-shrink: 0;
        }

        #chat p {
            display: inline;
        }

        #log p {
            position: relative;
        }

        #log p::before {
            content: "▧";
            position: absolute;
            left: -1.5rem;
        }
        
        p {
            word-break: break-word;
        }

        p.image {
            background: #f4daf5;
        }

        img {
            max-width: 70%;
            max-height: 48vh;
            margin-right: 1rem;
        }
    </style>

</head>
<body>
<div id="login">
    <label> Private key:
        <input id="privateKey" value="4148b0040c190b1058d5e478d5406a237ebae15b8d22184dc5660c17232ce011">
    </label>
    <label> Relay address:
        <input id="relay" value="wss://relay.nostr.band/">
        <!-- wss://relay.nostr.band/  ||  ws://localhost:8080/ -->
    </label>
    <button onclick="logIn()">Login</button>
</div>

<div id="wrapper" hidden>

    <div id="chat">
    </div>

    <div id="log">
    </div>

    <!-- <div id="actionBar">
        <label class="actionBarTextField">
            <input id="messageInput" placeholder="Type your message...">
        </label>
        <button onclick="sendMessage()" class="submitButton">
        </button>
    </div> -->

</div>

<script>
    let socket;

    function logIn() {
        document.getElementById('login').hidden = true;
        document.getElementById('wrapper').hidden = false;

        const relay = document.getElementById("relay").value;
        socket = new WebSocket(relay);

        subscribe(socket);
    }

    //if we receive EOSE, we change this to true, to start prepending the events that come after.
    function subscribe(socket) {
        const {schnorr} = nobleSecp256k1;
        const currentPrivateKey = document.getElementById('privateKey').value;
        const subId = bitcoinjs.ECPair.makeRandom().privateKey.toString("hex").substring(0, 16);
        //let filter = {"kinds": [1]};
        //let filter = {"kinds": [1], "authors": [schnorr.getPublicKey(currentPrivateKey)]}
        const filter = {"kinds": [1], "limit": 10};

        socket.addEventListener('message', async function (message) {
            handleMessage(message);
        });

        socket.addEventListener('open', async function (e) {
            console.log("connected to " + relay);

            // Sending a subscription request
            let subscription = ["REQ", subId, filter];
            console.log('Subscription:', subscription);
            socket.send(JSON.stringify(subscription));
        });
    }

    const savedUserData = new Map();


    function renderContact(metadata) {
        const contactsDiv = document.getElementById("contacts");

        const contact = document.createElement("p");

        contact.innerText = metadata.name;

        if (metadata.picture) {
            const avatar = document.createElement("img");
            avatar.src = metadata.picture;
            avatar.style.width = "32px";
            avatar.style.height = "32px";
            contact.appendChild(avatar);
        }

        contactsDiv.appendChild(contact);
    }

    function markLastLogAsImage() {
        const targetEl = document.querySelector("#log");

        const el = targetEl.firstChild;

        el.classList.add("image");
    }

    function log(event) {
        const targetEl = document.querySelector("#log");

        const el = document.createElement("p");

        event.tags.forEach((tag) => {
            
            ["strong", "code", "em"].forEach((type, i) => {
                if (tag[i] === undefined) {
                    return;
                }

                const argEl = document.createElement(type);
                argEl.innerText = tag[i];

                el.append(argEl);
            });
        });

        el.append(document.createElement("hr"));

        [event.content].forEach((arg) => {
            
            const argEl = document.createElement("code");
            argEl.innerText = arg;

            el.append(argEl);
        });

        if (targetEl.children.length > 500) {
            targetEl.removeChild(targetEl.lastChild);
        }

        targetEl.prepend(el);
    }

    function handleMessage(message) {
        let [type, subId, event] = JSON.parse(message.data); // do not remove the subid, it will not work without!

        log(event);

        // Logging the message and content

        if (type === "EOSE") {
            console.log(type);
            endOfStoredEventsReached = true; //we have received EOSE, start prepending now.
            fetchMetadata(socket);
        }

        if (type === "EVENT" && event.kind === 0) {
            // [EVENT, idsub, {kind: 0, pubkey: pubkey, content: content}]
            const metadata = JSON.parse(event.content);
            savedUserData.set(event.pubkey, metadata);

            renderContact(metadata);

            if (ongoingUserRequests.has(event.pubkey)) {
                ongoingUserRequests.get(event.pubkey).forEach(el => {
                    el.textContent = metadata.name;
                });
                ongoingUserRequests.delete(event.pubkey);
            }
        }

        if (type === "EVENT" && event.kind === 1) {
            const image_url = event.content.match(/(https?:\/\/.*\.(?:png|jpg|jpeg|gif|webp|mp4|webm))/ig);

            if (!image_url || !image_url.length) {
                return;
            }

            markLastLogAsImage();

            const targetEl = document.getElementById("chat");
            const eventEl = document.createElement("p");

            image_url.forEach((url) => {
                const img = document.createElement("img");
                img.src = url;
                eventEl.appendChild(img);
            });

            if (targetEl.children.length > 50) {
                targetEl.removeChild(targetEl.lastChild);
            }

            targetEl.prepend(eventEl);
        }
    }

    function sendMessage() {
        // Importing necessary modules

        let {schnorr} = nobleSecp256k1;
        let sha256 = bitcoinjs.crypto.sha256;

        // Retrieving values from input fields
        let privKey = document.getElementById("privateKey").value;
        let pubKey = schnorr.getPublicKey(privKey);
        let relay = document.getElementById("relay").value;

        let socket = new WebSocket(relay);

        // Handling incoming messages
        socket.addEventListener('message', async function (message) {
            // Parsing the incoming message
            let [type, subId, event] = JSON.parse(message.data); // do not remove the type or subid, it will not work without!
            let {content} = event || {};

            // Logging the message and content
            if (type === "EVENT") {
                console.log('message:', event);
                console.log('content:', content);
            }
            if (type === "EOSE") {
                console.log(type);
            }


            // Uncomment the following lines if decryption is required
            // if (kind === 4) {
            //    content = await decrypt(privKey, event.pubkey, content)
            // }
        });

        // Handling the WebSocket connection
        socket.addEventListener('open', async function (e) {
            console.log("connected to " + relay);

            // Creating and sending a signed event

            let newEvent = {
                "content": document.getElementById("messageInput").value,
                "created_at": Math.floor(Date.now() / 1000),
                "kind": 1,
                "tags": [],
                "pubkey": pubKey,
            };

            let signedEvent = await getSignedEvent(newEvent, privKey);
            console.log('signedEvent:', signedEvent);
            socket.send(JSON.stringify(["EVENT", signedEvent]));
            document.getElementById('messageInput').value = "";
        });

        // Function to get a signed event
        async function getSignedEvent(event, privateKey) {
            let eventData = JSON.stringify([
                0,                      // Reserved for future use
                event['pubkey'],        // The sender's public key
                event['created_at'],    // Unix timestamp
                event['kind'],          // Message “kind” or type
                event['tags'],          // Tags identify replies/recipients
                event['content']        // Your note contents
            ]);
            event.id = sha256(eventData).toString('hex');
            event.sig = await schnorr.sign(event.id, privateKey);
            return event;
        }
    }

    const ongoingUserRequests = new Map();

    function getUserInfo(pubKey, el) {

        if (ongoingUserRequests.has(pubKey)) {
            ongoingUserRequests.get(pubKey).push(el);
        } else {
            ongoingUserRequests.set(pubKey, [el]);
        }
    }

    function fetchMetadata(socket) {
        let subId = bitcoinjs.ECPair.makeRandom().privateKey.toString("hex").substring(0, 16);
        let filter = {"authors": [...ongoingUserRequests.keys()], "kinds": [0]};

        console.log("fetchMetadata called", ["REQ", subId, filter])

        socket.send(JSON.stringify(["REQ", subId, filter]));

        fetchMetadata = () => { console.log("fetchMetadata called again") };
    }


</script>
</body>
</html>